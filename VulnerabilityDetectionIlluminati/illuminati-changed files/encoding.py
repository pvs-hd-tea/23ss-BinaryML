from typing import Any, Optional

import numpy as np
import torch

from torch_geometric.data import Data
from torch_geometric.transforms import BaseTransform
from torch_sparse import SparseTensor
from scipy.sparse.linalg import eigs, eigsh


def add_node_attr(data: Data, value: Any, attr_name: Optional[str] = None) -> Data:
    if attr_name is None:
        if 'x' in data:
            x = data.x.view(-1, 1) if data.x.dim() == 1 else data.x
            data.x = torch.cat([x, value.to(x.device, x.dtype)], dim=-1)
        else:
            data.x = value
    else:
        data[attr_name] = value

    return data


class AddLaplacianEigenvectorPE(BaseTransform):
    def __init__(
        self,
        k: int,
        attr_name: Optional[str] = 'laplacian_eigenvector_pe',
        is_undirected: bool = False,
        **kwargs,
    ):
        self.k = k
        self.attr_name = attr_name
        self.is_undirected = is_undirected
        self.kwargs = kwargs

    def __call__(self, data: Data) -> Data:
        num_nodes = data.num_nodes
        edge_index, edge_weight = SparseTensor.from_edge_index(data.edge_index, edge_weight=data.edge_weight).coo()

        edge_index, edge_weight = edge_index.cpu().numpy(), edge_weight.cpu().numpy()
        edge_index, edge_weight = get_laplacian(edge_index, edge_weight, normalization='sym', num_nodes=num_nodes)

        L = to_scipy_sparse_matrix(edge_index, edge_weight, num_nodes)

        eig_vals, eig_vecs = eig_fn(
            L,
            k=self.k + 1,
            which='SR' if not self.is_undirected else 'SA',
            return_eigenvectors=True,
            **self.kwargs,
        )

        eig_vecs = np.real(eig_vecs[:, eig_vals.argsort()])
        pe = torch.from_numpy(eig_vecs[:, 1:self.k + 1])
        sign = -1 + 2 * torch.randint(0, 2, (self.k, ))
        pe *= sign

        data = add_node_attr(data, pe, attr_name=self.attr_name)
        return data


class AddRandomWalkPE(BaseTransform):
    def __init__(
        self,
        walk_length: int,
        attr_name: Optional[str] = 'random_walk_pe',
    ):
        self.walk_length = walk_length
        self.attr_name = attr_name

    def __call__(self, data: Data) -> Data:
        row, col = SparseTensor.from_edge_index(data.edge_index).coo().cpu().numpy()
        N = data.num_nodes

        value = data.edge_weight
        if value is None:
            value = torch.ones(data.num_edges, device=row.device)
        value = torch.scatter_add(torch.zeros(N, device=row.device), dim=0, index=row, src=value).clamp(min=1)[row]
        value = 1.0 / value

        adj = to_torch_csr_tensor(data.edge_index, value, size=data.size())

        out = adj
        pe_list = [get_self_loop_attr(*to_edge_index(out), num_nodes=N)]
        for _ in range(self.walk_length - 1):
            out = out @ adj
            pe_list.append(get_self_loop_attr(*to_edge_index(out), N))
        pe = torch.stack(pe_list, dim=-1)

        data = add_node_attr(data, pe, attr_name=self.attr_name)
        return data
